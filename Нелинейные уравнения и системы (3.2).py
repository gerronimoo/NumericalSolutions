#Нелинейные уравнения и системы

# №3.2

#импортируем модули
import math
import random

#наша функция из условия
def f(x):
    return 4.0 * math.sin(x) + 1.0 - x

#метод секущих, g - функция: решается уравнение g(x) = 0
#x0 и x1 - начальные приближения
#eps - точность
def secant_method(g, x0, x1, eps):
    #число итераций    
    num_iters = 0 
    while True:
        f0 = g(x0)
        f1 = g(x1)
        xn = x1 - (x1 - x0) * f1 / (f1 - f0) #итерационная формула секущих
        #если новое приближение не сильно отличается от последнего ((abs(x1 - xn) < eps - модуль разности не превышает точность), то возвращаем новое приближение как корень
        if (abs(x1 - xn) < eps):
            return xn
        #обновляем два последних приближения
        x0 = x1
        x1 = xn
        #обновляем число итераций
        num_iters += 1
        
        #если много раз итерируемся, то метод не сошелся, возвращаем неопределенность
        if (num_iters > 100):
            return float('NaN')

random.seed(1223) #зерно для генератора случайных чисел. это какое-то число (можно взять любым), чтобы результат был одним и тем же при разных запусках программы

roots = [] #массив корней
for i in range(100): #цикл 100 раз
    #r1 и r2 - два начальных приближения
    #выбираем их случайным образом из отрезка [-10, 10]
    r1 = random.uniform(-10, 10)
    r2 = random.uniform(-10, 10)
    sol = secant_method(f, r1, r2, 1e-9) #находим корень уравнения f(x) = 0 с точностью 10 в -9 степени, используя начальные приближения 
    if not(any(abs(x - sol) < 1e-9 for x in roots)): #если корня нет среди найденных с точностью 10 в -9 степени, то добавим корень в массив
        roots.append(sol)
    
roots.sort() #сортируем массив корней

print(roots) #выведем массив корней